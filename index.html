<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Audio Painting ‚Äî Fixed Layout</title>
<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet">
<style>
  :root{
    --bg:#07060b;
    --card:#0f1720;
    --accent1:#00e0ff;
    --accent2:#7c5cff;
    --muted:#9fb0d0;
  }
  *{box-sizing:border-box}
  body{
    margin:0;
    font-family:"Poppins",system-ui,Segoe UI,Roboto,Arial;
    background:linear-gradient(180deg,#02030a 0%, #071025 100%);
    color:#e6f6ff;
    min-height:100vh;
    display:flex;
    align-items:flex-start;
    justify-content:center;
    padding:40px 20px;
  }

  .wrap{
    width:100%;
    max-width:900px;
    border-radius:18px;
    padding:28px;
    background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    box-shadow:0 20px 60px rgba(2,6,23,0.7);
  }

  header{ text-align:center; margin-bottom:18px }
  h1{ margin:0; font-size:36px; color:var(--accent1); text-shadow:0 6px 30px rgba(0,224,255,0.12); }
  p.lead{ margin:8px 0 18px; color:var(--muted) }

  .mode {
    display:flex;
    gap:12px;
    justify-content:center;
    margin-bottom:22px;
  }
  .mode button{
    border:0;
    padding:10px 22px;
    border-radius:26px;
    cursor:pointer;
    background:#0b1320;
    color:var(--muted);
    font-weight:600;
  }
  .mode button.active{
    background:linear-gradient(90deg,var(--accent1),var(--accent2));
    color:#02111a;
    box-shadow:0 8px 28px rgba(124,92,255,0.12);
  }

  /* main card area */
  .card{
    background:linear-gradient(180deg, rgba(255,255,255,0.015), rgba(255,255,255,0.01));
    border-radius:14px;
    padding:20px;
    border:1px solid rgba(255,255,255,0.02);
  }

  /* upload rows stacked vertically to avoid overlap */
  .upload-row{
    display:block;           /* full-width stack */
    margin: 14px 0;         /* spacing so boxes don't touch */
  }

  .file-box{
    display:flex;
    align-items:center;
    justify-content:center;
    gap:12px;
    width:100%;
    padding:22px;
    border-radius:12px;
    border:2px dashed rgba(124,92,255,0.35);
    background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));
    color:var(--muted);
    font-size:16px;
    cursor:pointer;
    transition:box-shadow .18s, transform .12s;
  }
  .file-box:hover{ box-shadow:0 10px 30px rgba(124,92,255,0.06); transform:translateY(-2px) }

  /* hidden inputs */
  input[type=file]{ display:none }

  .filename{
    margin-top:8px;
    color:#bcdcee;
    font-size:13px;
    min-height:18px;
    text-align:center;
    word-break:break-all;
  }

  .actions{ display:flex; gap:12px; justify-content:center; margin-top:18px; }
  .btn{
    background:linear-gradient(90deg,var(--accent1),var(--accent2));
    border:0;
    color:#02111a;
    padding:12px 20px;
    border-radius:12px;
    cursor:pointer;
    font-weight:700;
    box-shadow:0 12px 30px rgba(0,0,0,0.45);
  }
  .link{
    display:inline-block;
    padding:10px 16px;
    border-radius:10px;
    background:rgba(255,255,255,0.02);
    color:var(--muted);
    border:1px solid rgba(255,255,255,0.02);
    text-decoration:none;
  }

  .result{ margin-top:16px; text-align:center; color:var(--muted) }

  /* responsive */
  @media (max-width:640px){
    .wrap{ padding:18px }
    h1{ font-size:28px }
    .file-box{ padding:16px; font-size:15px }
  }
</style>
</head>
<body>
  <div class="wrap" role="main">
    <header>
      <h1>üéß Audio Painting</h1>
      <p class="lead">Hide images inside WAV audio (LSB). Encode, decode & visualize.</p>
      <div class="mode" aria-hidden="false">
        <button id="btnEncode" class="active" type="button">Encode</button>
        <button id="btnDecode" type="button">Decode</button>
      </div>
    </header>

    <section class="card" id="encodeCard">
      <!-- audio input -->
      <div class="upload-row">
        <label class="file-box" id="audioLabel" for="audioInput">
          üéµ Drop or choose WAV audio
        </label>
        <input id="audioInput" type="file" accept="audio/wav" />
        <div id="audioName" class="filename" aria-live="polite"></div>
      </div>

      <!-- image input -->
      <div class="upload-row">
        <label class="file-box" id="imageLabel" for="imageInput">
          üñºÔ∏è Drop or choose image
        </label>
        <input id="imageInput" type="file" accept="image/*" />
        <div id="imageName" class="filename" aria-live="polite"></div>
      </div>

      <!-- actions -->
      <div class="actions">
        <button id="encodeBtn" class="btn" type="button">üîí Encode</button>
        <a id="downloadStego" class="link" style="display:none" download="stego.wav">‚¨áÔ∏è Download Stego</a>
      </div>

      <div class="result" id="encodeResult"></div>
    </section>

    <section class="card" id="decodeCard" style="margin-top:14px; display:none">
      <!-- decode upload -->
      <div class="upload-row">
        <label class="file-box" id="decodeLabel" for="decodeInput">
          üéµ Drop or choose stego WAV
        </label>
        <input id="decodeInput" type="file" accept="audio/wav" />
        <div id="decodeName" class="filename" aria-live="polite"></div>
      </div>

      <div class="actions">
        <button id="decodeBtn" class="btn" type="button">üîì Decode</button>
        <a id="downloadImg" class="link" style="display:none" download="recovered.png">‚¨áÔ∏è Download Recovered Image</a>
      </div>

      <div class="result" id="decodeResult"></div>
    </section>
  </div>

<script>
/* UI wiring (no overlap, separate inputs) */
const btnEncode = document.getElementById('btnEncode');
const btnDecode = document.getElementById('btnDecode');
const encodeCard = document.getElementById('encodeCard');
const decodeCard = document.getElementById('decodeCard');

btnEncode.addEventListener('click', ()=>{ btnEncode.classList.add('active'); btnDecode.classList.remove('active'); encodeCard.style.display='block'; decodeCard.style.display='none'; });
btnDecode.addEventListener('click', ()=>{ btnDecode.classList.add('active'); btnEncode.classList.remove('active'); encodeCard.style.display='none'; decodeCard.style.display='block'; });

/* File inputs & labels */
const audioInput = document.getElementById('audioInput');
const imageInput = document.getElementById('imageInput');
const decodeInput = document.getElementById('decodeInput');

const audioLabel = document.getElementById('audioLabel');
const imageLabel = document.getElementById('imageLabel');
const decodeLabel = document.getElementById('decodeLabel');

const audioName = document.getElementById('audioName');
const imageName = document.getElementById('imageName');
const decodeName = document.getElementById('decodeName');

audioLabel.addEventListener('click', ()=> audioInput.click());
imageLabel.addEventListener('click', ()=> imageInput.click());
decodeLabel.addEventListener('click', ()=> decodeInput.click());

audioInput.addEventListener('change', ()=> {
  audioName.textContent = audioInput.files[0] ? `${audioInput.files[0].name} ‚Ä¢ ${Math.round(audioInput.files[0].size/1024)} KB` : '';
});
imageInput.addEventListener('change', ()=> {
  imageName.textContent = imageInput.files[0] ? `${imageInput.files[0].name} ‚Ä¢ ${Math.round(imageInput.files[0].size/1024)} KB` : '';
});
decodeInput.addEventListener('change', ()=> {
  decodeName.textContent = decodeInput.files[0] ? `${decodeInput.files[0].name} ‚Ä¢ ${Math.round(decodeInput.files[0].size/1024)} KB` : '';
});

/* Simple LSB encode/decode (keeps previous functional logic) */
function bytesToInt16(samplesBytes){
  const s = new Int16Array(samplesBytes.length/2);
  for(let i=0;i<s.length;i++) s[i] = (samplesBytes[i*2+1]<<8) | samplesBytes[i*2];
  return s;
}
function int16ToBytes(int16){
  const b = new Uint8Array(int16.length*2);
  for(let i=0;i<int16.length;i++){
    b[i*2] = int16[i] & 0xff;
    b[i*2+1] = (int16[i] >> 8) & 0xff;
  }
  return b;
}

document.getElementById('encodeBtn').addEventListener('click', async ()=>{
  const resDiv = document.getElementById('encodeResult');
  resDiv.textContent = '';
  document.getElementById('downloadStego').style.display='none';
  if(!audioInput.files[0] || !imageInput.files[0]) { resDiv.textContent = 'Select both audio and image.'; return; }

  try{
    const audioBuf = await audioInput.files[0].arrayBuffer();
    const header = new Uint8Array(audioBuf.slice(0,44));
    const sampleBytes = new Uint8Array(audioBuf.slice(44));
    const samples = bytesToInt16(sampleBytes);

    const imgBytes = new Uint8Array(await imageInput.files[0].arrayBuffer());
    // Prepend a small header so decoder can detect image type and length:
    // signature "STEGIMG" (7), mime length byte (1), mime string (up to 32), 4 bytes little-endian payload length -> then payload
    const mime = imageInput.files[0].type || 'image/png';
    const encMime = new TextEncoder().encode(mime);
    const mimeField = new Uint8Array(32); mimeField.fill(0);
    mimeField.set(encMime.slice(0,32),0);
    const signature = new TextEncoder().encode('STEGIMG'); //7 bytes
    const lenBytes = new Uint8Array(4); new DataView(lenBytes.buffer).setUint32(0, imgBytes.length, true);

    const payload = new Uint8Array(signature.length + mimeField.length + lenBytes.length + imgBytes.length);
    let off = 0; payload.set(signature,off); off+=signature.length; payload.set(mimeField,off); off+=mimeField.length; payload.set(lenBytes,off); off+=lenBytes.length; payload.set(imgBytes,off);

    // Convert payload to bit stream (LSB per sample)
    const totalBits = payload.length * 8;
    if(totalBits > samples.length){ resDiv.textContent = 'Audio too short for this image. Choose a longer audio or smaller image.'; return; }

    const stego = new Int16Array(samples); // copy
    let bitPos = 0;
    for(let i=0;i<payload.length;i++){
      const byte = payload[i];
      for(let b=0;b<8;b++){
        const bit = (byte >> b) & 1; // little-endian bit order in byte
        const sampleIdx = bitPos;
        const sample = stego[sampleIdx];
        stego[sampleIdx] = (sample & ~1) | bit;
        bitPos++;
      }
    }

    const outBytes = new Uint8Array([...header, ...int16ToBytes(stego)]);
    const blob = new Blob([outBytes], { type: 'audio/wav' });
    const url = URL.createObjectURL(blob);
    const dl = document.getElementById('downloadStego');
    dl.href = url; dl.style.display='inline-block';
    resDiv.textContent = `Success ‚Äî stego audio ready (${Math.round(blob.size/1024)} KB)`;
  }catch(e){
    console.error(e); resDiv.textContent = 'Encoding failed: '+e.message;
  }
});

document.getElementById('decodeBtn').addEventListener('click', async ()=>{
  const resDiv = document.getElementById('decodeResult');
  resDiv.textContent = '';
  document.getElementById('downloadImg').style.display='none';
  if(!decodeInput.files[0]){ resDiv.textContent = 'Select a stego WAV first.'; return; }

  try{
    const audioBuf = await decodeInput.files[0].arrayBuffer();
    const sampleBytes = new Uint8Array(audioBuf.slice(44));
    const samples = bytesToInt16(sampleBytes);

    // Read bits from samples
    const bits = new Uint8Array(samples.length);
    for(let i=0;i<samples.length;i++) bits[i] = samples[i] & 1;

    // Convert bits -> bytes (little-endian inside original encoding)
    const byteLen = Math.floor(bits.length / 8);
    const bytes = new Uint8Array(byteLen);
    for(let i=0;i<byteLen;i++){
      let v = 0;
      for(let b=0;b<8;b++){
        const bit = bits[i*8 + b];
        v |= (bit<<b);
      }
      bytes[i] = v;
    }

    // Look for signature "STEGIMG"
    const sig = new TextEncoder().encode('STEGIMG');
    let idx = -1;
    for(let i=0;i<bytes.length - sig.length; i++){
      let ok = true;
      for(let j=0;j<sig.length;j++) if(bytes[i+j] !== sig[j]) { ok=false; break; }
      if(ok){ idx = i; break; }
    }
    if(idx < 0){ resDiv.textContent = 'No hidden image found.'; return; }

    // read mime field and length
    const mimeStart = idx + sig.length;
    const mimeField = bytes.slice(mimeStart, mimeStart + 32);
    const mime = new TextDecoder().decode(mimeField).replace(/\0/g,'') || 'image/png';
    const lenStart = mimeStart + 32;
    const len = new DataView(bytes.buffer).getUint32(lenStart, true);
    const payloadStart = lenStart + 4;
    const payload = bytes.slice(payloadStart, payloadStart + len);

    // produce blob and show
    const blob = new Blob([payload], { type: mime });
    const url = URL.createObjectURL(blob);

    // show and allow download
    resDiv.innerHTML = `Recovered image (${mime}, ${len} bytes)`;
    const imgDownload = document.getElementById('downloadImg');
    imgDownload.href = url; imgDownload.style.display='inline-block';
    // create image element inside result area (remove previous if any)
    const existing = document.querySelector('#decodeResult img');
    if(existing) existing.remove();
    const img = document.createElement('img');
    img.src = url;
    img.style.maxWidth = '360px';
    img.style.marginTop = '12px';
    document.getElementById('decodeResult').appendChild(img);
  }catch(e){
    console.error(e); resDiv.textContent = 'Decoding failed: '+e.message;
  }
});
</script>
</body>
</html>
